/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright 2019 Joyent, Inc.
 *
 */

/*
 * - VminfodClient
 *
 * A client class that can be used to make basic GET requests to the vminfod
 * service. This interface is only intended for internal-to-the-platform
 * usage.
 *
 * var vc = new require('vminfod/client').VminfodClient();
 *
 * vc.ping(cb);
 * vc.status(cb);
 * vc.vms(cb);
 * vc.vm(zonename, cb);
 * vc.get(urlPath, cb); // arbitrary GET request
 *
 * Where `cb` has the signature function(err, result)
 *
 * - VminfodEventStream
 *
 * A class that can be used to interface directly with the vminfod events
 * stream (GET /events).  It creates a readable stream in objectMode where each
 * call to read returns an object parsed from the event stream that represents
 * a single event.
 *
 * var vs = new require('vminfod/client').VminfodEventStream();
 *
 * vs.once('ready', function (ev) {
 *     // stream ready
 * });
 *
 * // create a live stream
 * vs.on('readable', function () {
 *     var ev;
 *     while ((ev = vs.read())) {
 *         console.log(JSON.stringify(ev));
 *     }
 * });
 *
 * // or instead, call a convenience function
 *
 * - VminfodEventStream#watchForEvent(obj, opts, cb)
 *
 * // wait 60 seconds for the zone_state to transition to "running"
 * var obj = {
 *     uuid: '<uuid>',
 *     vm: {
 *         zone_state: 'running'
 *     }
 * };
 * var opts = {
 *     timeout: 60 * 1000, // error after 60 seconds if event is not seen
 *     teardown: true, // end the stream at any error or when the event is seen
 *     startFresh: true, // clear any unread events first
 *     catchErrors: true // bind .on('error') and callback if any is seen
 * };
 *
 * // watchForEvent returns a function that can be used to cancel the watch.
 * // It is bascially a shortcut to the callback that is fired - any arguments
 * // passed to cancel will be applied to the callback given.
 * var cancel = vs.watchForEvent(obj, opts, function (err, ev) {
 *     if (err) {
 *         // either the stream ended prematurely or the event was not seen for
 *         // 60 seconds
 *     }
 *     // `ev` is the event that matched "obj"
 *     console.log(JSON.stringify(ev, null, 2));
 * });
 *
 * - VminfodEventStream#watchForChanges(obj, changes, opts, cb)
 *
 * // wait 30 seconds for the quota to change from 10 to 20
 * // just like watchForEvent, this object is matched against the event object
 * // before any further processing is done.
 * var obj = {
 *     uuid: '<uuid>',
 * };
 * // same as watchForEvent
 * var opts = {
 *     timeout: 30 * 1000,
 *     teardown: true,
 *     startFresh: true,
 *     catchErrors: true
 * };
 * // every element in the array must be matched for the callback to fire
 * // successfully (logical AND).
 * var changes = [
 *    {
 *        path: ['quota'],
 *        action: 'changed',
 *        oldValue: 10,
 *        newValue: 20
 *    }
 * ];
 * var cancel = vs.watchForChanges(obj, changes, opts, function (err) {
 *     if (err) {
 *         // either the stream ended prematurely or the event was not seen for
 *         // 30 seconds
 *     }
 *     // matched the changes given
 * });
 *
 * - VminfodWatcher
 *
 * A class that wraps VminfodEventStream and can be used to mirror vminfod
 * effectively.  Under the hood, a VminfodEventStream will be created and used
 * to manage an internal object of all VMs that vminfod is aware of.  This way,
 * the internal object is kept up to date by getting notified of any changes
 * from the vminfod service.  For example:
 *
 * var vw = new require('vminfod/client').VminfodWatcher();
 *
 * vw.once('ready', function (ev) {
 *     // returns an object that maps zonenames to vm objects
 *     var vms = vw.vms();
 *     // vms[<uuid>] == vmobj
 *
 *     var vmobj = vw.vm('<uuid>');
 *     // vmobj is an object, or undefined if it is not found
 * });
 *
 * vw.on('create', cb); // a VM was created
 * vw.on('modify', cb); // a VM was modified
 * vw.on('delete', cb); // a VM was deleted
 * vw.on('event', cb);  // a VM was created/modified/deleted
 *
 * All callbacks will be called with a single argument - the event from the
 * vminfod stream.
 *
 * The calls to `vw.vms` and `vw.vm` are very fast, because they just check
 * a local JavaScript object (as opposed to making an HTTP call to the
 * vminfod service) that is kept up to date by the VminfodEventStream.
 */

var EventEmitter = require('events').EventEmitter;
var http = require('http');
var stream = require('stream');
var os = require('os');
var util = require('util');
var qs = require('querystring');
var f = util.format;

var assert = require('/usr/node/node_modules/assert-plus');
var bunyan = require('/usr/node/node_modules/bunyan');
var diff = require('/usr/vm/node_modules/diff');
var LineStream = require('/usr/node/node_modules/linestream');
var hrtime = require('/usr/vm/node_modules/hrtime');

/*
 * When creating an event stream, the daemon *should* respond with a "ready"
 * event when the connection is established.  In the event that there is a bug,
 * or something wrong with the daemon and it doesn't send a ready event, we
 * ensure that we don't indefinetely for an event that won't come.
 */
var DEFAULT_READY_TIMEOUT = 30 * 1000;

module.exports.VminfodClient = VminfodClient;
module.exports.VminfodEventStream = VminfodEventStream;
module.exports.VminfodWatcher = VminfodWatcher;
module.exports.createVmWatcher = createVmWatcher;

var log = bunyan.createLogger({
    level: 'debug',
    name: 'vminfod/client',
    stream: process.stderr,
    serializers: bunyan.stdSerializers
});

function noop() {}

/*
 * VminfodClient class
 */
function VminfodClient(opts) {
    var self = this;

    var _log;

    assert(self instanceof VminfodClient, 'must be called with "new"');

    opts = opts || {};
    if (typeof (opts) === 'string') {
        opts = {name: opts};
    }

    assert.object(opts, 'opts');

    _log = opts.log || log;

    self.vc_host = opts.host || '127.0.0.1';
    self.vc_port = opts.port || 9090;
    self.vc_name = opts.name || _log.fields.name;
    self.vc_logger = _log.child({client: self.vc_name});

    assert.string(self.vc_host, 'self.vc_host');
    assert.number(self.vc_port, 'self.vc_port');
    assert.string(self.vc_name, 'self.vc_name');
    assert.object(self.vc_logger, 'self.vc_logger');
}

/*
 * Perform a GET request to the Vminfod daemon.
 *
 * @param {Object|String} opts - options to pass to http.request, if this is a
 *                               string it is used as opts.path (the endpoint)
 * @param {Function} cb - callback of signature cb(err, data)
 *   - err - any possible error, including non-200 statusCode or failure to
 *           parse JSON response
 *   - data - the JSON.parse'd data returned from the server
 * @return {HTTPRequest} req - the HTTP request object
 */
VminfodClient.prototype.get = function vminfodClientGet(opts, cb) {
    var self = this;

    var reqOpts;
    var req;

    if (typeof (opts) === 'string') {
        opts = {path: opts};
    }

    assert.object(opts, 'opts');
    assert.func(cb, 'cb');

    reqOpts = {
        host: self.vc_host,
        port: self.vc_port,
        method: 'GET',
        headers: {
            'user-agent': makeUserAgent(self.vc_name)
        }
    };
    Object.keys(opts).forEach(function copyOptToReqOpts(key) {
        reqOpts[key] = opts[key];
    });

    req = http.request(reqOpts, function httpRequestMade(res) {
        var body = '';
        var err;

        if (res.statusCode !== 200) {
            err = new Error('bad statusCode: ' + res.statusCode);
            err.code = err.statusCode = res.statusCode;
            res.destroy();
            cb(err);
            return;
        }

        res.setEncoding('utf8');
        body = '';
        res.on('readable', function resReadable() {
            var chunk;
            while ((chunk = res.read()) !== null) {
                body += chunk;
            }
        });
        res.on('end', function resEnd() {
            var d;
            try {
                d = JSON.parse(body);
            } catch (e) {
                self.vc_logger.error({err: e, opts: reqOpts},
                    'failed to parse request body from %s %s',
                    reqOpts.method, reqOpts.path);
                cb(e);
                return;
            }
            cb(null, d);
        });
    });

    req.on('error', function reqError(e) {
        cb(e);
        req.destroy();
    });

    req.end();

    return req;
};

/*
 * shortcuts for common endpoints, equivalent to:
 *   get('/status', cb), get('/vms', cb), etc.
 */
['ping', 'status', 'vms'].forEach(function makeVminfodClientFunc(s) {
    VminfodClient.prototype[s] = function vminfodClientGetWrapper(opts, cb) {
        var self = this;

        if (typeof (opts) === 'function') {
            cb = opts;
            opts = {};
        }

        assert.object(opts, 'opts');
        assert.func(cb, 'cb');

        opts.path = '/' + s;

        if (opts.query) {
            opts.path += '?' + qs.stringify(opts.query);
        }

        return self.get(opts, cb);
    };
});

/*
 * Get a information for a specific vm given the zonename
 *
 * @param {String} zonename - the zonename (UUID most likely)
 * @param {Function} cb - same signature and usage as .get()
 */
VminfodClient.prototype.vm = function vminfodClientVm(zonename, cb) {
    var self = this;

    assert.string(zonename, 'zonename');
    assert.func(cb, 'cb');

    var endpoint = '/vms/' + encodeURIComponent(zonename);

    return self.get(endpoint, cb);
};

/*
 * Create a new vminfod stream by creating a persistent HTTP request to vminfod
 *
 */
function VminfodEventStream(opts) {
    var self = this;

    var _log;

    assert(self instanceof VminfodEventStream, 'must be called with "new"');

    opts = opts || {};
    if (typeof (opts) === 'string') {
        opts = {name: opts};
    }

    assert.object(opts, 'opts');

    // become a transform stream
    stream.Transform.call(self, {objectMode: true});

    _log = opts.log || log;

    // process opts
    self.vs_host = opts.host || '127.0.0.1';
    self.vs_port = opts.port || 9090;
    self.vs_name = opts.name || _log.fields.name;
    self.vs_parseReady = opts.parseReady || false;
    self.vs_readyTimeout = opts.hasOwnProperty('readyTimeout') ?
        opts.readyTimeout : DEFAULT_READY_TIMEOUT;
    self.vs_logger = _log.child({client: self.vs_name});

    assert.string(self.vs_host, 'self.vs_host');
    assert.number(self.vs_port, 'self.vs_port');
    assert.string(self.vs_name, 'self.vs_name');
    assert.bool(self.vs_parseReady, 'self.vs_parseReady');
    assert.number(self.vs_readyTimeout, 'self.vs_readyTimeout');
    assert.object(self.vs_logger, 'self.vs_logger');

    self.start();
}
util.inherits(VminfodEventStream, stream.Transform);

/*
 * start the stream by opening a persistent HTTP connection
 */
VminfodEventStream.prototype.start = function vminfodEventStreamStart(opts) {
    var self = this;

    var reqOpts;

    opts = opts || {};

    assert.object(opts, 'opts');
    assert.ok(!self.vs_req, 'VminfodEventStream already started');

    self.vs_startedTime = process.hrtime();

    reqOpts = {
        host: self.vs_host,
        port: self.vs_port,
        method: 'GET',
        path: '/events',
        headers: {
            'user-agent': makeUserAgent(self.vs_name)
        }
    };
    Object.keys(opts).forEach(function copyOptToReqOpts(key) {
        reqOpts[key] = opts[key];
    });

    self.vs_req = http.request(reqOpts, function httpRequestMade(res) {
        var err;
        var ls;

        if (res.statusCode !== 200) {
            err = new Error('bad statusCode: ' + res.statusCode);
            err.code = res.statusCode;
            res.destroy();
            self.vs_logger.error({err: err}, '%s', err.message);
            self.emit('error', err);
            return;
        }

        ls = new LineStream();
        res.pipe(ls).pipe(self);
        res.on('end', function resEnd() {
            if (self.vs_req) {
                err = new Error('VminfodEventStream ended prematurely');
                self.vs_logger.error({err: err}, '%s', err.message);
                self.emit('error', err);
                return;
            }
        });
    });
    self.vs_req.setTimeout(0);
    self.vs_req.end();

    /*
     * create a timer to ensure that the "ready" event seen.  This also allows
     * us to ensure the "ready" event is only seen once.
     */
    assert(!self.vs_ready_timeout, '"ready" timeout already exists');
    self.vs_ready_timeout = setTimeout(function readyTimeout() {
        var err = new Error(util.format(
            'VminfodEventStream ready timeout (%dms) exceeded',
            self.vs_readyTimeout));

        self.vs_logger.error({err: err}, '%s', err.message);
        self.vs_ready_timeout = null;
        self._abort(err);
    }, self.vs_readyTimeout);

    /*
     * capture any request errors and reemit them by this module
     */
    self.vs_req.on('error', function reqError(err) {
        self.vs_logger.error({err: err}, 'VminfodEventStream request error');
        self._abort(err);
    });

    return self.vs_req;
};

/*
 * the transform method to process http body-by-line
 */
VminfodEventStream.prototype._transform =
    function _transform(chunk, encoding, cb) {

    var self = this;

    var ev;
    var line = chunk.toString('utf8');
    var now;
    var parsed;
    var vms;

    if (!self.vs_req) {
        // we are stopped - ignore any incoming data
        self.vs_logger.trace({line: line},
            'stream stopped - ignoring line from vminfod');
        cb();
        return;
    }

    try {
        ev = JSON.parse(line);
        ev.date = new Date(ev.date);
        assert.ok(isFinite(ev.date), 'invalid ev.date');
    } catch (e) {
        // any JSON parse failure is a fatal error
        self.vs_logger.error({err: e, line: line},
            'failed to parse output line');
        self._abort(e);
        return;
    }

    switch (ev.type) {
    case 'ready':
        assert(self.vs_ready_timeout, '"ready" event already seen');
        if (self.vs_parseReady) {
            /*
             * This is less-than-ideal, but because vminfod pre-serializes
             * vm data to cut down on the number of calls to JSON.stringify
             * required, we have to JSON.parse the vms property, as its been
             * serialized twice.
             *
             * Also, we convert the vms array to an object indexed off of the
             * "zonename" (uuid) property
             */
            now = process.hrtime();
            vms = {};
            parsed = JSON.parse(ev.vms);
            parsed.forEach(function mapEachVm(vmobj) {
                vms[vmobj.zonename] = vmobj;
            });
            ev.vms = vms;
            self.vs_logger.debug({vms: parsed.length},
                'vminfod took %s to parse "ready" event, %d vms total',
                hrtime.hrtimeDeltaPretty(process.hrtime(), now), parsed.length);
        }
        self.vs_logger.debug('vminfod event stream ready - took %s',
            hrtime.hrtimeDeltaPretty(process.hrtime(), self.vs_startedTime));
        self.emit('ready', ev);
        self._clearReadyTimeout();
        break;
    default:
        self.push(ev);
        break;
    }
    cb();
};

/*
 * clear all unread objects from the internal buffer
 */
VminfodEventStream.prototype._clearEvents =
    function vminfodEventStreamClearEvents() {

    var self = this;

    var i = 0;

    while (self.read()) {
        i++;
    }

    self.vs_logger.debug({i: i}, 'vminfod cleared %d events', i);
};

/*
 * cleanly stop the VminfodEventStream by destroying the request
 */
VminfodEventStream.prototype.stop = function vminfodEventStreamStop() {
    var self = this;

    if (self.vs_req) {
        self.vs_logger.debug('vminfod event stream stopped');
        self.vs_req.destroy();
        self.vs_req = null;
    }
    self._clearReadyTimeout();
};

/*
 * same as above, but emit an error
 */
VminfodEventStream.prototype._abort = function _vminfodEventStreamAbort(e) {
    var self = this;

    self.stop();
    self.emit('error', e);
};

/*
 * Convenience function to clear the ready timeout if it is set
 */
VminfodEventStream.prototype._clearReadyTimeout =
    function _vminfodEventStreamClearReadyTimeout() {

    var self = this;

    if (self.vs_ready_timeout) {
        self.vs_logger.trace('clearing ready timeout');
        clearTimeout(self.vs_ready_timeout);
        self.vs_ready_timeout = null;
    }
};

/*
 * Watch for a specific event (with an optional timeout), and
 * optionally teardown the stream when it is received
 */
VminfodEventStream.prototype.watchForEvent =
    function vminfodEventStreamWatchForEvent(obj, opts, cb) {

    var self = this;

    var events = [];
    var isDone = false;
    var timeout;

    if (typeof (opts) === 'function') {
        cb = opts;
        opts = {};
    }

    assert.object(obj, 'obj');
    assert.object(opts, 'opts');
    assert.optionalNumber(opts.timeout, 'opts.timeout');
    assert.optionalBool(opts.teardown, 'opts.teardown');
    assert.optionalBool(opts.catchErrors, 'opts.catchErrors');
    assert.optionalBool(opts.startFresh, 'opts.startFresh');
    assert.func(cb, 'cb');

    if (opts.timeout) {
        timeout = setTimeout(function vminfodEventStreamWatchForEventTimeout() {
            var msg = f('vminfod watchForEvent "%s" timeout exceeded',
                self.vs_name);

            self.vs_logger.error({obj: obj, events: events},
                '%s - unmatched events', msg);

            var err = new Error(msg);
            err.code = 'ETIMEOUT';
            done(err);
        }, opts.timeout);
    }

    self.vs_logger.debug({
        obj: obj,
        opts: opts
    }, 'vminfod watchForEvent created');

    self.on('readable', processEvents);
    if (opts.startFresh) {
        self._clearEvents();
    } else {
        processEvents();
    }

    function processEvents() {
        var ev;
        while ((ev = self.read()) !== null) {
            processEvent(ev);
        }
    }

    function processEvent(ev) {
        if (isDone) {
            return;
        }

        events.push(ev);

        if (!objSameValues(obj, ev)) {
            return;
        }

        self.vs_logger.debug({obj: obj},
            'vminfod watchForEvent matched event');

        done(null, ev);
    }

    function onerror(e) {
        self.vs_logger.error({err: e},
            'vminfod watchForEvent stream error');
        done(e);
    }
    if (opts.catchErrors) {
        self.on('error', onerror);
    }

    function done(err, o) {
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }
        if (opts.teardown || (opts.catchErrors && err)) {
            self.stop();
        }
        if (opts.catchErrors) {
            self.removeListener('error', onerror);
        }
        self.removeListener('readable', processEvents);
        isDone = true;
        cb(err, o);
    }

    function cancelFn(err, o) {
        if (isDone) {
            self.vs_logger.warn('vminfod watchForEvent cancelled after done');
            return;
        }

        self.vs_logger.debug('vminfod watchForEvent cancelled');
        done(err, o);
    }

    return cancelFn;
};

/*
 * watch for one or more changes (with an optional timeout), and
 * optionally teardown the stream when it is seen
 */
VminfodEventStream.prototype.watchForChanges =
    function vminfodEventStreamWatchForChanges(obj, changes, opts, cb) {

    var self = this;

    var events = [];
    var isDone = false;
    var timeout;
    var total;

    if (typeof (opts) === 'function') {
        cb = opts;
        opts = {};
    }

    assert.object(obj, 'obj');
    assert.array(changes, 'changes');
    changes.forEach(function loopChangesBase(_changes) {
        // change can be an object, or an array of objects
        if (!Array.isArray(_changes)) {
            _changes = [_changes];
        }
        assert.arrayOfObject(_changes, 'changes');
        _changes.forEach(function loopChangesSecondLevel(change) {
            /*
             * In order for a "change" object to be valid, it must have the
             * "path" property set, as well as any other property indicating
             * change type.
             */
            assert.array(change.path, 'change.path');
            var otherkeys = Object.keys(change).filter(
                function filterPath(key) {

                return key !== 'path';
            });
            assert(otherkeys.length > 0, 'change only has "path" set');
        });
    });
    assert.object(opts, 'opts');
    assert.optionalNumber(opts.timeout, 'opts.timeout');
    assert.optionalBool(opts.teardown, 'opts.teardown');
    assert.optionalBool(opts.catchErrors, 'opts.catchErrors');
    assert.optionalBool(opts.startFresh, 'opts.startFresh');
    assert.func(cb, 'cb');

    total = changes.length;

    self.vs_logger.debug({
        obj: obj,
        opts: opts,
        changes: changes,
        total: total
    }, 'vminfod watchForChanges created');

    if (total === 0) {
        self.vs_logger.warn('vminfod watchForChanges called '
            + 'with empty changes array');

        if (opts.startFresh) {
            self._clearEvents();
        }

        done();
        return noop;
    }

    if (opts.timeout) {
        timeout = setTimeout(
            function vminfodEventStreamWatchForChangesTimeout() {

            var msg = f('vminfod watchForChanges "%s" timeout exceeded',
                self.vs_name);

            self.vs_logger.error({changes: changes, events: events},
                '%s - unmatched events', msg);

            var err = new Error(msg);
            err.code = 'ETIMEOUT';
            done(err);
        }, opts.timeout);
    }

    self.vs_logger.trace({changes: changes},
        'beginning watch for vminfod changes');

    self.on('readable', processEvents);
    if (opts.startFresh) {
        self._clearEvents();
    } else {
        processEvents();
    }
    function processEvents() {
        var ev;
        while ((ev = self.read()) !== null) {
            processEvent(ev);
        }
    }

    function processEvent(ev) {
        if (isDone) {
            return;
        }

        // filter out events that don't match our predicate (obj)
        if (!objSameValues(obj, ev)) {
            return;
        }

        self.vs_logger.trace({ev: ev},
            'inspecting possible match from vminfod');

        // loop changes found from vminfod
        (ev.changes || []).forEach(function processChange(changeSeen) {
            /*
             * Compare to changes we are looking for.  Return false to remove
             * the item from the changes array (meaning we matched it) or true
             * to keep it in the array (meaning it was not a match).
             *
             * It's possible that there are duplicate changes we are looking
             * for, so only filter out one element per change.
             */
            var hasMatched = false;
            changes = changes.filter(function filterChanges(wantedArr) {
                var changePart;
                var changePath;
                var match;
                var originalWantedPath;
                var wanted;
                var wantedPart;
                var wantedPath;

                if (isDone) {
                    return false;
                }

                if (hasMatched) {
                    return true;
                }

                if (!Array.isArray(wantedArr)) {
                    wantedArr = [wantedArr];
                }

                for (var i = 0; i < wantedArr.length; i++) {
                    wanted = wantedArr[i];
                    originalWantedPath = wanted.path.slice(0);

                    wantedPath = wanted.path;
                    changePath = changeSeen.path;

                    /*
                     * Skip this change if the path of the wanted variable
                     * doesn't match
                     */
                    if (wantedPath.length !== changePath.length) {
                        continue;
                    }

                    // Ensure each part of the "path" match.
                    match = true;
                    for (var j = 0; j < wantedPath.length; j++) {
                        wantedPart = wantedPath[j];
                        changePart = changePath[j];
                        if (!(wantedPart === null
                            || wantedPart === changePart)) {
                            match = false;
                            break;
                        }
                    }
                    if (!match) {
                        continue;
                    }

                    /*
                     * Compare the event fired to the event we want, omitting
                     * the "path" variable as it was checked above
                     */
                    delete wanted.path;
                    match = objSameValues(wanted, changeSeen);
                    wanted.path = originalWantedPath;

                    if (match) {
                        /*
                         * We matched, this change will be removed from the
                         * array
                         */
                        hasMatched = true;
                        self.vs_logger.trace({changeSeen: changeSeen,
                            match: match}, 'vminfod change match');

                        return false;
                    }
                }

                /*
                 * If we get here, the event didn't match any of the changes
                 * wanted so we keep the change and try again when a new event
                 * is received.
                 */
                return true;
            });

            /*
             * If we are here and the event didn't match any of the changes we
             * wanted we push the event onto the "events" array to be logged
             * later for debugging purposes if the changes are never satisified.
             */
            if (!hasMatched) {
                events.push(changeSeen);
            }
        });

        if (isDone) {
            changes.length = 0;
        }

        if (changes.length === 0) {
            // No more changes to wait for, we're done!
            self.vs_logger.debug('vminfod watchForChanges all changes matched');
            done();
            return;
        }

        self.vs_logger.debug({remaining: changes.length, total: total},
            'vminfod watchForChanges %d/%d changes remaining',
            changes.length, total);
    }

    function onerror(e) {
        self.vs_logger.error({err: e}, 'vminfod stream error');
        done(e);
    }
    if (opts.catchErrors) {
        self.on('error', onerror);
    }

    function done(err, o) {
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }
        if (opts.teardown || (opts.catchErrors && err)) {
            self.stop();
        }
        if (opts.catchErrors) {
            self.removeListener('error', onerror);
        }
        self.removeListener('readable', processEvents);
        isDone = true;
        cb(err, o);
    }

    function cancelFn(err, o) {
        if (isDone) {
            self.vs_logger.warn('vminfod watchForChanges cancelled after done');
            return;
        }

        self.vs_logger.debug('vminfod watchForChanges cancelled');
        done(err, o);
    }

    return cancelFn;
};

/*
 * Create a new VminfodEventStream and manage an internal object that houses
 * all known vmobjs that is updated when a new event is seen
 *
 */
function VminfodWatcher(opts) {
    var self = this;

    var _log;

    assert(self instanceof VminfodWatcher, 'must be called with "new"');

    opts = opts || {};
    if (typeof (opts) === 'string') {
        opts = {name: opts};
    }

    assert.object(opts, 'opts');

    _log = opts.log || log;

    self.vw_name = opts.name || _log.fields.name;
    self.vw_logger = _log.child({client: self.vw_name});
    self.vw_vms = {};

    assert.string(self.vw_name, 'self.vw_name');
    assert.object(self.vw_logger, 'self.vw_logger');

    self.vw_vs = new VminfodEventStream({
        name: self.vw_name,
        log: self.vw_logger,
        parseReady: true
    });

    self.vw_vs.once('ready',
        function vminfodWatcherVminfodEventStreamReady(ready_ev) {

        self.vw_vms = ready_ev.vms;
        self.emit('ready');
    });

    self.vw_vs.on('readable',
        function vminfodWatcherVminfodEventStreamReadable() {

        var ev;
        while ((ev = self.vw_vs.read())) {
            self._handleEvent(ev);
        }
    });
}
util.inherits(VminfodWatcher, EventEmitter);

/*
 * Handle an incoming vminfod update
 */
VminfodWatcher.prototype._handleEvent =
    function _vminfodWatcherHandleEvent(ev) {

    var self = this;

    assert.object(ev, 'ev');
    assert.string(ev.type, 'ev.type');

    switch (ev.type) {
    case 'create':
    case 'modify':
        self.vw_vms[ev.zonename] = ev.vm;
        break;
    case 'delete':
        delete self.vw_vms[ev.zonename];
        break;
    default:
        assert(false, 'unknown vminfod event type: ' + ev.type);
        break;
    }

    self.emit(ev.type, ev);
    self.emit('event', ev);
};

/*
 * return all vms
 */
VminfodWatcher.prototype.vms = function vminfodWatcherVms() {
    var self = this;

    return self.vw_vms;
};

/*
 * return a specific vm
 */
VminfodWatcher.prototype.vm = function vminfodWatcherVm(zonename) {
    var self = this;

    var vm;

    assert.string(zonename, 'zonename');

    if (self.vw_vms.hasOwnProperty(zonename)) {
        vm = self.vw_vms[zonename];
    }

    return vm;
};

/*
 * stop the watcher
 */
VminfodWatcher.prototype.stop = function vminfodWatcherStop() {
    var self = this;

    self.vw_vs.stop();
};




/*
 * A VmWatcher is a convenience wrapper around `VminfodEventStream` to
 * wait on one or more vminfod events on a single VM. The typical use case is:
 *
 * - create a VmWatcher for VM $ZONENAME to start watching for relevant events
 *   (or event "changes")
 * - do some action on the VM
 * - wait for the given events (with a given timeout)
 * - cleanup
 *
 * In code that can look like:
 *
 *      // Example values.
 *      var ZONENAME = 'c6c56fca-6ab6-11e9-bbbb-7f35c0181c27';
 *      var CHANGES = [
 *          { path: ['zone_state'], action: 'changed', newValue: 'configured' },
 *          { path: ['zfs_filesystem'], action: 'removed' },
 *          { path: ['zpool'], action: 'removed' }
 *      ];
 *      var TIMEOUT = 5 * 1000;
 *
 *      var vmObj;
 *      var vmWatcher;
 *      vasync.pipeline({funcs: [
 *          function startWatchingForEvents(_, next) {
 *              vminfod.createVmWatcher({
 *                  log: log,
 *                  zonename: ZONENAME,
 *                  // Optionally determine if should get the initial VM obj.
 *                  obtainVm: true,
 *                  // Pass in "events" and/or modify event "changes" to start
 *                  // watching for. Alternatively, one can separately call
 *                  // `vmWatcher.startWatch(...)`.
 *                  changes: CHANGES
 *              }, function (err, watcher, vm) {
 *                  // This returns a watcher when the underlying event
 *                  // stream is "ready".
 *                  vmWatcher = watcher;
 *                  vmObj = vm;
 *                  next(err);
 *              );
 *          },
 *
 *          function doTheAction(_, next) {
 *              // Example action:
 *              zoneadm(['-u', ZONENAME, 'uninstall', '-F'], function (err) {
 *                  if (err) {
 *                      next(err);
 *                  }
 *                  // ...
 *              });
 *          },
 *
 *          function waitForTheEvents(_, next) {
 *              vmWatcher.wait({timeout: TIMEOUT}, function (err) {
 *                  next(err);
 *              });
 *          }
 *      ]}, function doneActionAndWatch(err) {
 *          vmWatcher.close();
 *          cb(err);
 *      });
 *
 * `vminfod.createVmWatcher` will create a vminfo event stream, wait for it
 * to be ready, then start watching for given events and/or event changes.
 * This does *not yet block* waiting for those events. Typically some action
 * is then performed on the VM. Only *then* do we start waiting for the
 * expected vminfod events (via `vmWatcher.wait()`).
 *
 * There is an advantage, over prior approaches, in waiting to start the timeout
 * after the VM action is complete. On very slow or overloaded servers the
 * VM action could take longer than the timeout. This convolved two concepts:
 * a timeout (if one is wanted) for the VM action and a timeout waiting to
 * ensure vminfod was up to date before returning.
 *
 * A `VmWatcher` instance may be re-used to watch for subsequent events/changes
 * by calling `clearWatch()` and then `startWatch(...)` again.
 *
 * @param {String} zonename - The VM zonename (a UUID).
 * @param {Object} log - A bunyan logger object.
 * @param {String} clientName - Optional. A string to identify the caller
 *      (a la HTTP user-agent). This is used for logging and error messages.
 * @param {Boolean} obtainVm - Optional, default false. Whether to obtain the
 *      initial vm object.
 * @param {Array} events - Optional. An array of event patterns to start
 *      watching for immediately. See `eventPatternMatch()` for details.
 * @param {Array} changes - Optional. An array of event change patterns to start
 *      watching for immediately. See `eventChangePatternMatch()` for details.
 * @param {Function} cb - Callback `function (err, vmWatcher)`. This calls back
 *      either on error, or when the vminfod event stream is ready (i.e. has
 *      responded with its "ready" event).
 */
function createVmWatcher(opts, cb) {
    assert.object(opts, 'opts');
    assert.uuid(opts.zonename, 'opts.zonename');
    assert.object(opts.log, 'opts.log');
    assert.optionalString(opts.clientName, 'opts.clientName');
    assert.optionalBool(opts.obtainVm, 'opts.obtainVm');
    assert.optionalArrayOfObject(opts.events, 'opts.events');
    assert.optionalArrayOfObject(opts.changes, 'opts.changes');
    assert.func(cb, 'cb');

    var calledBack = false;
    var watcher = new VmWatcher({
        zonename: opts.zonename,
        log: opts.log,
        clientName: opts.clientName,
        obtainVm: opts.obtainVm
    });

    // This `vmObj` is only non-null if obtainVm=true and the VM exists.
    watcher.once('ready', function onReady(vmObj) {
        if (opts.events || opts.changes) {
            watcher.startWatch({
                events: opts.events,
                changes: opts.changes
            });
        }
        if (!calledBack) {
            calledBack = true;
            cb(null, watcher, vmObj);
        }
    });

    // Handle an error before the 'ready' event.
    watcher.once('error', function onError(err) {
        if (!calledBack) {
            calledBack = true;
            cb(err);
        }
    });
}

function VmWatcher(opts) {
    var self = this;

    assert.ok(self instanceof VmWatcher, 'must be called with "new"');
    assert.object(opts, 'opts');
    assert.object(opts.log, 'opts.log');
    assert.string(opts.zonename, 'opts.zonename');
    assert.optionalString(opts.clientName, 'opts.clientName');
    assert.optionalBool(opts.obtainVm, 'opts.obtainVm');

    self.zonename = opts.zonename;
    self.clientName = opts.clientName || opts.log.fields.name;
    self.log = opts.log.child({client: opts.clientName}, true);
    self._vsErr = null;

    self.clearWatch();

    self.vs = new VminfodEventStream({
        log: self.log,
        name: self.clientName,

        // Dev Note:
        //
        // A reasonably common use case of VmWatcher is to want the current VM
        // object. To support this, we use the available "ready" event from
        // VminfodEventStream. However, this isn't a great design.
        //
        // The vminfod "GET /events" endpoint starts with a "ready" event that
        // includes the VM object for *all* VMs. As well, with current vminfod
        // that "event.vms" is a double-stringified structure that must be
        // parsed again. On nightly (admitted slow) hardware, with only 30 VMs,
        // this takes up to 1-2ms to parse.
        //
        // It would be more appropriate to have this not be O(number of VMs)
        // somehow, whether that is via "GET /events?zonename=$zonename" that
        // scopes to a single VM; or a "ready" event that does not include all
        // this data and the client separately calls "GET /vm/$zonename"; or
        // something else.
        parseReady: opts.obtainVm
    });

    self.vs.once('ready', function onVsReady(readyEv) {
        var vmObj = null;
        if (opts.obtainVm) {
            vmObj = readyEv.vms[opts.zonename] || null;
        }
        self.emit('ready', vmObj);
    });

    // Error handling: If there is an error on the vminfod event stream we
    // want to:
    // - error out any current waiters
    // - save the error to return on any subsequent `.wait()` calls
    self.vs.on('error', function onVsError(err) {
        self._vsErr = err;
        if (self._waiters) {
            self._waiters.forEach(function oneWaiter(waiter) {
                waiter.finish(self._vsErr);
                clearTimeout(waiter.timeout);
            });
            self._waiters = null;
        }
        self.emit('error', err);
    });

    self.vs.on('readable', function onVsReadable() {
        var ev;
        while ((ev = self.vs.read())) {
            self._handleEvent(ev);
        }
    });
}
util.inherits(VmWatcher, EventEmitter);


/*
 * Clear a current "watch" (as started by `startWatch()`). This must be called
 * before re-calling `<vmWatcher>.startWatch()` to re-use a VmWatcher.
 */
VmWatcher.prototype.clearWatch = function vmWatcherClearWatch() {
    var self = this;
    self._watching = false;
    self._eventPatterns = null;
    self._changePatterns = null;
    self._unusedEvents = null;
    self._waiters = null;
};


/*
 * Start a "watch" -- i.e. start watching for the given event patterns or
 * event change patterns on the vminfod event stream for this VM.
 *
 * The watch is "complete" when all patterns have been matched by an event.
 * When watching incoming events, only a *single* event pattern or event change
 * pattern will be matched per event. This allows watching for duplicate
 * events, by specifying the pattern multiple times.
 *
 * @param {Array} events - Optional. An array of event patterns to start
 *      watching for immediately. See `eventPatternMatch()` for details.
 * @param {Array} changes - Optional. An array of event change patterns to start
 *      watching for immediately. See `eventChangePatternMatch()` for details.
 */
VmWatcher.prototype.startWatch = function vmWatcherStartWatch(opts) {
    assert.object(opts, 'opts');
    assert.ok(opts.events || opts.changes,
        'must specify at least one of opts.events or opts.changes');
    assert.optionalArrayOfObject(opts.events, 'opts.events');
    // Validate change patterns.
    if (opts.changes) {
        var validateChangePatternObj = function (chPatObj) {
            assert.array(chPatObj.path, '<change pattern object>.path');
            assert.ok(Object.keys(chPatObj).length > 1,
                '<change pattern object> must have a "path" and at least '
                + 'one additional field');
        };
        opts.changes.forEach(function validateChangePattern(chPat) {
            if (Array.isArray(chPat)) {
                chPat.forEach(validateChangePatternObj);
            } else {
                validateChangePatternObj(chPat);
            }
        });
    }

    var self = this;
    assert.equal(self._watching, false,
        'cannot <VmWatcher>.startWatch() when already watching, '
        + 'call <VmWatcher>.clearWatch() to clear');
    self._watching = true;

    // Note: We aren't doing a deep copy here, so these individual pattern
    // object *could* be changed by the caller.
    self._eventPatterns = opts.events ? opts.events.slice() : [];
    self._changePatterns = opts.changes ? opts.changes.slice() : [];

    self.log.debug({eventPatterns: self._eventPatterns,
        changePatterns: self._changePatterns}, 'VmWatcher.startWatch');

    // In case it is useful for debugging, we retain a list of events for
    // this VM that did not match against watch "events" and "changes". This
    // is included in logging on `.wait()` timeout errors.
    self._unusedEvents = [];

    // Array of `{onFinish: <function>, timeout: <timeout handle>}` for each
    // call to `.wait()`.
    self._waiters = [];
};


/*
 * Wait for the current watch to be complete. I.e., block until incoming events
 * on the vminfod event stream have matched all given event and event change
 * patterns.
 *
 * If the events have already been observed between the time `startWatch`
 * and this `wait` are called, then this will call back immediately (in the
 * next tick).
 *
 * @param {Number} opts.timeout - A number of milliseconds after which to
 *      timeout.
 * @param {Function} cb - callback with signature `function (err)`. On timeout,
 *      `err` is set to a new Error object with `err.code = 'ETIMEOUT'`.
 *      Otherwise, `err` is `null`.
 */
VmWatcher.prototype.wait = function vmWatcherWait(opts, cb) {
    assert.object(opts, 'opts');
    assert.finite(opts.timeout, 'opts.timeout'); // in milliseconds
    assert.func(cb, 'cb');

    var onFinish;
    var onTimeout;
    var self = this;
    var start = process.hrtime();
    var waiter;

    assert.ok(self._watching,
        'called <VmWatcher>.wait() before <VmWatcher>.startWatch() was called');

    onFinish = function (err) {
        var elapsed = hrtime.hrtimeDelta(process.hrtime(), start);
        var waitTime = elapsed[0] + elapsed[1]/1e9;
        self.log.debug({err: err, waitTime: waitTime}, 'VmWatcher.wait finish');
        cb(err);
    };
    onTimeout = function () {
        // Remove this waiter from `self._waiters`, so its `onFinish` isn't
        // called if the watched events come in later.
        for (var i = 0; i < self._waiters.length; i++) {
            if (self._waiters[i] === waiter) {
                self._waiters.splice(i, 1);
                break;
            }
        }

        // Callback with an ETIMEOUT error.
        var msg = f('vminfod.VmWatcher "%s" wait timeout exceeded',
            self.clientName);
        var err = new Error(msg);
        err.code = 'ETIMEOUT';
        self.log.debug({
            err: err,
            waitTime: opts.timeout / 1000,
            remainingEvents: self._eventPatterns,
            remainingChanges: self._changePatterns,
            unusedEvents: self._unusedEvents
        }, 'VmWatcher.wait timeout');
        cb(err);
    };


    // Error immediately if there was an earlier event stream error.
    if (self._vsErr) {
        onFinish(self._vsErr);
        return;
    }

    // Quick out if no unmatched events.
    if (self._eventPatterns.length === 0 && self._changePatterns.length === 0) {
        setImmediate(function noNeedToWait() {
            onFinish(null);
        });
        return;
    }

    waiter = {
        finish: onFinish,
        timeout: setTimeout(onTimeout, opts.timeout)
    };
    self._waiters.push(waiter);
};

VmWatcher.prototype.close = function vmWatcherClose() {
    // Clear any waiters timeouts.
    var self = this;
    if (self._waiters) {
        for (var i = 0; i < self._waiters.length; i++) {
            clearTimeout(self._waiters[i].timeout);
        }
        self._waiters = null;
    }

    this.vs.stop();
};


/*
 * Determine if the vminfod `event` matches the event `pattern`.
 *
 * A vminfod event looks like this:
 *      {
 *        // `type` is "create", "delete", or "modify" (see vminfod.js)
 *        "type": "modify",
 *        "date": "2019-04-29T22:40:11.787Z",
 *        "zonename": "16ae8c35-00e3-c322-bae5-92002c12b763",
 *        "uuid": "16ae8c35-00e3-c322-bae5-92002c12b763",
 *        "vm": {
 *          // the full VM object, as from `vmadm get`.
 *          "zonename": "16ae8c35-00e3-c322-bae5-92002c12b763",
 *          "quota": 25,
 *          "brand": "lx",
 *          ...
 *        },
 *        // Events of type "modify" have this "changes" array. See
 *        // `eventChangePatternMatch()` to match "changes" entries.
 *        "changes": [
 *          {
 *            "prettyPath": "zone_state",
 *            "path": [
 *              "zone_state"
 *            ],
 *            "action": "changed",
 *            "oldValue": "installed",
 *            "newValue": "ready"
 *          },
 *          ...
 *        ]
 *      }
 *
 * An "event pattern" is an object of the same form as an event, that is
 * matched field-by-field for equality. Examples that would match above.
 *
 *      {"type": "modify"}
 *      {"type": "modify", "vm": {"brand": "lx"}}
 *
 * @returns {Boolean} `true` if it matches, `false` if not.
 */
function eventPatternMatch(event, pattern) {
    return objSameValues(pattern, event);
}

/*
 * Determine if the vminfod `event` "changes" entry, `change`, matches the given
 * event change `pattern`.
 *
 * See `eventPatternMatch` above for an example of a full vminfod event object.
 * A `change` is one of the object entries in the `event.changes` array. E.g.:
 *
 *          {
 *            "prettyPath": "zone_state",
 *            "path": [
 *              "zone_state"
 *            ],
 *            "action": "changed",
 *            "oldValue": "installed",
 *            "newValue": "ready"
 *          }
 *
 * another example:
 *
 *          {
 *            "prettyPath": "dobjs.snapshots.zones/ffe...bad/data/manatee.*",
 *            "path": [
 *              "dobjs",
 *              "snapshots",
 *              "zones/ffe...bad/data/manatee",
 *              null
 *            ],
 *            "action": "added",
 *            "newValue": {
 *              "snapname": "1556731621350",
 *              "dataset": "zones/ffe...bad/data/manatee",
 *              "created_at": 1556731621,
 *              "size": 1860768
 *            }
 *          }
 *
 *
 * A "change pattern" is either:
 * (a) an object with a "path" field and at least one other, for example:
 *
 *          {
 *              path: ['zone_state'],
 *              action: 'changed',
 *              newValue: 'ready'
 *          }
 *
 *     another example:
 *
 *          {
 *              path: ['disks', null, 'missing'],
 *              action: 'removed'
 *          }
 *
 * (b) or, an array of such objects, e.g.:
 *
 *          [
 *              {
 *                  path: ['state'],
 *                  action: 'changed',
 *                  newValue: 'running'
 *              },
 *              {
 *                  path: ['state'],
 *                  action: 'changed',
 *                  newValue: 'stopped'
 *              }
 *          ]
 *
 *
 * A change pattern object is matched against a change by checking each field
 * for equality. However, the "path" field is required and has special case
 * matching. A "path" is an array of strings or `null` values. A `null` value
 * in the array matches any value:
 *     `['disks', null, 'missing']` matches `['disks', 'foo', 'missing']`
 *
 * A change pattern *array* matches a change object if *any of its pattern
 * object entries* match the change object.
 *
 * Typically the "prettyPath" field is *not* used for matching. The "path"
 * field is required and is the more appropriate field to use. See the
 * "../diff.js" file for details on the change object format.
 *
 * @returns {Boolean} `true` if it matches, `false` if not.
 */
function eventChangePatternMatch(change, pattern) {
    assert.object(change, 'change');

    var i;
    var patternObjMatch = function (patternObj) {
        assert.object(patternObj, 'patternObj');
        assert.array(patternObj.path, 'patternObj.path');

        var chPath = change.path;
        var j;
        var patPath = patternObj.path;
        var match;

        // Special case "path" field.
        if (patPath.length !== chPath.length) {
            return false;
        }
        for (j = 0; j < patPath.length; j++) {
            if (!(patPath[j] === chPath[j] || patPath[j] === null)) {
                return false;
            }
        }

        // Compare the rest of the fields.
        //
        // We temporarily delete/re-add the "path" field so we can more
        // easily use the generic `objSameValues()` without having to copy
        // objects.
        delete patternObj.path;
        match = objSameValues(patternObj, change);
        patternObj.path = patPath;

        return match;
    };


    if (Array.isArray(pattern)) {
        // Logical OR: if any of the pattern objects match, then return true.
        for (i = 0; i < pattern.length; i++) {
            if (patternObjMatch(pattern[i])) {
                return true;
            }
        }
        return false;
    } else {
        return patternObjMatch(pattern);
    }
}

VmWatcher.prototype._handleEvent = function _vmWatcherHandleEvent(event) {
    // Attempt to match the new event to `self._eventPatterns` and
    // `self._changePatterns`. If both those arrays go empty, then notify
    // any `self._waiters`. We consume at most one pattern per event/change,
    // to allow matching duplicate events/changes.

    var ch;
    var i;
    var j;
    var matchedEventPattern = null;
    var matchedChangePatterns;
    var pat;
    var self = this;
    var watchComplete;

    // Only consider events for this VM, and while we a watch is active.
    if (!self._watching || event.zonename !== self.zonename) {
        return;
    }

    self.log.trace({event: event}, 'VmWatcher _handleEvent');

    // Try to match an event pattern.
    if (self._eventPatterns.length) {
        for (i = 0; i < self._eventPatterns.length; i++) {
            pat = self._eventPatterns[i];
            if (eventPatternMatch(event, pat)) {
                matchedEventPattern = pat;
                self._eventPatterns.splice(i, 1);
                break;
            }
        }
    }

    // Try to match each event.changes entry to a change pattern.
    if (self._changePatterns.length && event.changes) {
        for (j = 0; j < event.changes.length; j++) {
            ch = event.changes[j];

            for (i = 0; i < self._changePatterns.length; i++) {
                pat = self._changePatterns[i];
                if (eventChangePatternMatch(ch, pat)) {
                    self._changePatterns.splice(i, 1);
                    if (!matchedChangePatterns) {
                        matchedChangePatterns = [];
                    }
                    matchedChangePatterns.push(pat);
                    break;
                }
            }
        }
    }

    if (!matchedEventPattern && !matchedChangePatterns) {
        self._unusedEvents.push(event);
    } else {
        watchComplete = (self._eventPatterns.length === 0
            && self._changePatterns.length === 0);
        self.log.debug(
            {
                event: event,
                matchedEventPattern: matchedEventPattern,
                matchedChangePatterns: matchedChangePatterns,
                watchComplete: watchComplete
            },
            'VmWatcher matched event');
        if (watchComplete) {
            for (i = 0; i < self._waiters.length; i++) {
                clearTimeout(self._waiters[i].timeout);
                self._waiters[i].finish(null);
            }
            self._waiters = null;
        }
    }
};




/*
 * Check to see that all key=>value pairs in "a" are found in "b".
 */
function objSameValues(a, b) {
    var d = diff(a, b).filter(function filterDiff(change) {
        return (change.action !== 'added');
    });
    return (d.length === 0);
}

/*
 * Given a name (arbitrary string) a string suitable for using as a User-Agent
 * is returned.
 */
function makeUserAgent(name) {
    assert.string(name, 'name');

    return util.format('%s - %s/%d (%s)',
        name || log.name,
        os.hostname(),
        process.pid,
        process.argv[1]);
}

/*
 * If called directly just hook a vminfo stream to stdout
 */
if (require.main === module) {
    var _vs = new VminfodEventStream();

    _vs.on('readable', function vminfodEventStreamReadable() {
        var ev;

        while ((ev = _vs.read()) !== null) {
            console.log(JSON.stringify(ev));
        }
    });
}
